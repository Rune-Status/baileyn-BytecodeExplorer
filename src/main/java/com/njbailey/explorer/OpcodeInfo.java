package com.njbailey.explorer;

public final class OpcodeInfo {
    public static final String[] OPCODE_NAMES = {
            "nop",
            "acount_null",
            "iconst_m1",
            "iconst_0",
            "iconst_1",
            "iconst_2",
            "iconst_3",
            "iconst_4",
            "iconst_5",
            "lconst_0",
            "lconst_1",
            "fconst_0",
            "fconst_1",
            "fconst_2",
            "dconst_0",
            "dconst_1",
            "bipush",
            "sipush",
            "ldc",
            "ldc_w",
            "ldc2_w",
            "iload",
            "lload",
            "fload",
            "dload",
            "aload",
            "iload_0",
            "iload_1",
            "iload_2",
            "iload_3",
            "lload_0",
            "lload_1",
            "lload_2",
            "lload_3",
            "fload_0",
            "fload_1",
            "fload_2",
            "fload_3",
            "dload_0",
            "dload_1",
            "dload_2",
            "dload_3",
            "aload_0",
            "aload_1",
            "aload_2",
            "aload_3",
            "iaload",
            "laload",
            "faload",
            "daload",
            "aaload",
            "baload",
            "caload",
            "saload",
            "istore",
            "lstore",
            "fstore",
            "dstore",
            "astore",
            "istore_0",
            "istore_1",
            "istore_2",
            "istore_3",
            "lstore_0",
            "lstore_1",
            "lstore_2",
            "lstore_3",
            "fstore_0",
            "fstore_1",
            "fstore_2",
            "fstore_3",
            "dstore_0",
            "dstore_1",
            "dstore_2",
            "dstore_3",
            "astore_0",
            "astore_1",
            "astore_2",
            "astore_3",
            "iastore",
            "lastore",
            "fastore",
            "dastore",
            "aastore",
            "bastore",
            "castore",
            "sastore",
            "pop",
            "pop2",
            "dup",
            "dup_x1",
            "dup_x2",
            "dup2",
            "dup2_x1",
            "dup2_x2",
            "swap",
            "iadd",
            "ladd",
            "fadd",
            "dadd",
            "isub",
            "lsub",
            "fsub",
            "dsub",
            "imul",
            "lmul",
            "fmul",
            "dmul",
            "idiv",
            "ldiv",
            "fdiv",
            "ddiv",
            "irem",
            "lrem",
            "frem",
            "drem",
            "ineg",
            "lneg",
            "fneg",
            "dneg",
            "ishl",
            "lshl",
            "ishr",
            "lshr",
            "iushr",
            "lushr",
            "iand",
            "land",
            "ior",
            "lor",
            "ixor",
            "lxor",
            "iinc",
            "i2l",
            "i2f",
            "i2d",
            "l2i",
            "l2f",
            "l2d",
            "f2i",
            "f2l",
            "f2d",
            "d2i",
            "d2l",
            "d2f",
            "i2b",
            "i2c",
            "i2s",
            "lcmp",
            "fcmpl",
            "fcmpg",
            "dcmpl",
            "dcmpg",
            "ifeq",
            "ifne",
            "iflt",
            "ifge",
            "ifgt",
            "ifle",
            "if_icmpeq",
            "if_icmpne",
            "if_icmplt",
            "if_icmpge",
            "if_icmpgt",
            "if_icmple",
            "if_acmpeq",
            "if_acmpne",
            "goto",
            "jsr",
            "ret",
            "tableswitch",
            "lookupswitch",
            "ireturn",
            "lreturn",
            "freturn",
            "dreturn",
            "areturn",
            "return",
            "getstatic",
            "putstatic",
            "getfield",
            "putfield",
            "invokevirtual",
            "invokespecial",
            "invokestatic",
            "invokeinterface",
            "invokedynamic",
            "new",
            "newarray",
            "anewarray",
            "arraylength",
            "athrow",
            "checkcast",
            "instanceof",
            "monitorenter",
            "monitorexit",
            "wide",
            "multianewarray",
            "ifnull",
            "ifnonnull",
            "goto_w",
            "jsr_w",
            "breakpoint",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "impdep1",
            "impdep2",
    };

    public static final String[] OPCODE_DESCRIPTIONS = {
            "Performs no operation.",
            "Push a null reference onto the stack.",
            "Load the int value -1 onto the stack.",
            "Load the int value 0 onto the stack.",
            "Load the int value 1 onto the stack.",
            "Load the int value 2 onto the stack.",
            "Load the int value 3 onto the stack.",
            "Load the int value 4 onto the stack.",
            "Load the int value 5 onto the stack.",
            "Push 0L (the number zero with type long) onto the stack.",
            "Push 1L (the number one with type long) onto the stack.",
            "Push 0.0f on the stack.",
            "Push 1.0f on the stack.",
            "Push 2.0f on the stack.",
            "Push the constant 0.0 (a double) onto the stack.",
            "Push the constant 1.0 (a double) onto the stack.",
            "Push a byte onto the stack as an integer value.",
            "Push a short onto the stack as an integer value.",
            "Push a constant #index from a constant pool (String, int, float, Class, MethodType, MethodHandle, or a dynamically-computed constant) onto the stack.",
            "Push a constant #index from a constant pool (String, int, float, Class, MethodType, MethodHandle, or a dynamically-computed constant) onto the stack. (wide index is constructed as indexbyte1 << 8 + indexbyte2)",
            "Push a constant #index from a constant pool (double, long, or a dynamically-computed constant) onto the stack. (wide index is constructed as indexbyte1 << 8 + indexbyte2)",
            "Load an int value from a local variable #index.",
            "Load a long value from a local variable #index.",
            "Load a float value from a local variable #index.",
            "Load a double value from a local variable #index.",
            "Load a reference onto the stack from a local variable #index.",
            "Load an int value from local variable 0.",
            "Load an int value from local variable 1.",
            "Load an int value from local variable 2.",
            "Load an int value from local variable 3.",
            "Load a long value from a local variable 0.",
            "Load a long value from a local variable 1.",
            "Load a long value from a local variable 2.",
            "Load a long value from a local variable 3.",
            "Load a float value from local variable 0.",
            "Load a float value from local variable 1.",
            "Load a float value from local variable 2.",
            "Load a float value from local variable 3.",
            "Load a double from local variable 0.",
            "Load a double from local variable 1.",
            "Load a double from local variable 2.",
            "Load a double from local variable 3.",
            "Load a reference onto the stack from local variable 0.",
            "Load a reference onto the stack from local variable 1.",
            "Load a reference onto the stack from local variable 2.",
            "Load a reference onto the stack from local variable 3.",
            "Load an int from an array.",
            "Load a long from an array.",
            "Load a float from an array.",
            "Load a double from an array.",
            "Load onto the stack a reference from an array.",
            "Load a byte or Boolean value from an array.",
            "Load a char from an array.",
            "Load short from an array.",
            "Store int value into local variable #index.",
            "Store long value into local variable #index.",
            "Store float value into local variable #index.",
            "Store double value into local variable #index.",
            "Store reference into local variable #index.",
            "Store int value in a local variable 0.",
            "Store int value in a local variable 1.",
            "Store int value in a local variable 2.",
            "Store int value in a local variable 3.",
            "Store a long value in a local variable 0.",
            "Store a long value in a local variable 1.",
            "Store a long value in a local variable 2.",
            "Store a long value in a local variable 3.",
            "Store a float value in a local variable 0.",
            "Store a float value in a local variable 1.",
            "Store a float value in a local variable 2.",
            "Store a float value in a local variable 3.",
            "Store a double value in a local variable 0.",
            "Store a double value in a local variable 1.",
            "Store a double value in a local variable 2.",
            "Store a double value in a local variable 3.",
            "Store a reference in a local variable 0.",
            "Store a reference in a local variable 1.",
            "Store a reference in a local variable 2.",
            "Store a reference in a local variable 3.",
            "Store an int into an array.",
            "Store a long into an array.",
            "Store a float into an array.",
            "Store a double into an array.",
            "Store a reference into an array.",
            "Store a byte or boolean value into an array.",
            "Store a char into an array.",
            "Store a short into an array.",
            "Discard the top value on the stack.",
            "Discard the top two values on the stack (or one value, if it's a double or long).",
            "Duplicate the value on top of the stack.",
            "Insert a copy of the top value into the stack two values from the top. Value 1 and Value 2 must not be of the type double or long.",
            "Insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top.",
            "Duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long).",
            "Duplicate two words and insert beneath third word.",
            "Duplicate two words and insert beneath fourth word.",
            "Swaps two top words on the stack (note that value1 and value2 must not be double or long).",
            "Add two ints.",
            "Add two longs.",
            "Add two floats.",
            "Add two doubles.",
            "Subtract two integers.",
            "Subtract two longs.",
            "Subtract two floats.",
            "Subtract two doubles.",
            "Multiply two integers.",
            "Multiply two longs.",
            "Multiply two floats.",
            "Multiply two doubles.",
            "Divide two integers.",
            "Divide two longs.",
            "Divide two floats.",
            "Divid two doubles.",
            "Logical int remainder.",
            "Remainder of division of two longs.",
            "Get the remainder from a division between two floats.",
            "Get the remainder from a division between two doubles.",
            "Negate an integer.",
            "Negate a long.",
            "Negate a float.",
            "Negate a double.",
            "Integer shift left.",
            "Bitwise shift left of a long value1 by int value2 positions.",
            "Int arithmetic shift right.",
            "Bitwise shift right of a long value1 by int value2 positions.",
            "Integer logical shift right.",
            "Bitwise shift right of a long value1 by int value2 positions, unsigned.",
            "Perform a bitwise AND on two integers.",
            "Bitwise AND of two longs.",
            "Bitwise OR of two integers.",
            "Bitwise OR of two longs.",
            "Bitwise XOR of two integers.",
            "Bitwise XOR of two longs.",
            "Increment local variable #index by signed byte const.",
            "Convert an integer into a long.",
            "Convert an integer into a float.",
            "Convert an integer into a double.",
            "Convert a long into an integer.",
            "Convert a long into a float.",
            "Covnert a long into a double.",
            "Convert a float into an integer.",
            "Convert a float into a long.",
            "Convert a float into a double.",
            "Convert a double into an integer.",
            "Convert a double into a long.",
            "Convert a double into a float.",
            "Convert an integer into a byte.",
            "Convert an integer into a character.",
            "Convert an integer into a short.",
            "Compare two longs.",
            "Compare two floats.",
            "Compare two floats.",
            "Compare two doubles.",
            "Compare two doubles.",
            "If value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "Goes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "Jump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack.",
            "Continue execution from address taken from a local variable #index (the asymmetry with jsr is intentional).",
            "Continue execution from an address in the table at offset index",
            "A target address is looked up from a table using a key and execution continues from the instruction at that address.",
            "Return an integer from a method.",
            "Return a long from a method.",
            "Return a float from a method.",
            "Return a double from a method.",
            "Return a reference from a method.",
            "Return void from a method.",
            "Get a static field value of a class, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 + indexbyte2).",
            "Set static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Get a field value of an object objectref, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 + indexbyte2).",
            "Set field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)",
            "Invoke virtual method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Invoke instance method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Invoke a static method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Invokes an interface method on object objectref and puts the result on the stack (might be void); the interface method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Invokes a dynamic method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Create new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2).",
            "Create new array with count elements of primitive type identified by atype",
            "Create a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 + indexbyte2) in the constant pool.",
            "Get the length of an array.",
            "Throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable).",
            "Checks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 + indexbyte2).",
            "Determines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 + indexbyte2).",
            "Enter monitor for object (\"grab the lock\" – start of synchronized() section).",
            "Exit monitor for object (\"release the lock\" – end of synchronized() section).",
            "Execute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment by is a signed 16 bit short.",
            "Create a new array of dimensions dimensions of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.].",
            "If value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "If value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2).",
            "Goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4).",
            "Jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack.",
            "Reserved for breakpoints in Java debuggers; should not appear in any class file.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Currently unassigned for opcodes and are reserved for future use.",
            "Reserved for implementation-dependent operations within debuggers; should not appear in any class file.",
            "Reserved for implementation-dependent operations within debuggers; should not appear in any class file.",
    };

    private OpcodeInfo() {}
}
